---
name: Branchy Language Rust
overview: "Самописный язык Branchy на Rust: ветки, переменные, inline-block, функции; встроенные строковые функции (Rust); интерпретатор по AST; бинарный формат; разработка через docker-compose с обязательными тестами."
todos: []
isProject: false
---

# План: язык Branchy на Rust

## Семантика и синтаксис

- **Программа** — ноль или более определений функций `!имя(:params) = ...`, затем одна верхнеуровневая ветка: `[ элемент_1; элемент_2; ... ]`.
- **Элемент** — литерал (число, идентификатор), вложенная ветка `[ ... ]`, либо **вызов с переменными** (см. ниже).
- **Выполнение**: из корневой ветки выбирается один случайный элемент; если ветка — рекурсия; если лист — он и есть результат. Итог: один случайно выбранный «лист» на выходе.

### Типы данных

- **Сейчас**: типов данных нет, все значения считаются **строками**. Идентификаторы и числа в синтаксисе (например `привет`, `123`) в рантайме — просто строки; результат подстановки и вывода — одна строка. В AST и интерпретаторе можно хранить литералы как строки или различать Ident/Num только для парсера, но при вычислении и выводе всё приводится к строке.
- **Позже (расширение)**: возможны объекты — по сути key-value словарь (Dictionary). Синтаксис и семантика взаимодействия с объектами не заданы, оставить задел в архитектуре (например единый тип значения `Value` с вариантами String / будущий Object), чтобы потом добавить без перелопачивания.

### Переменные и блоки

- **Синтаксис вызова**: `имя :param1 :param2 ... { определения }`.
  - Слева от `{ }` — «блок выше»: идентификатор и список параметров (`:name`).
  - Внутри `{ }` — определения переменных: `:name = значение;` (сколько угодно). **Значение** — либо ветка (массив) `[ ... ]`, либо **одна строка** (литерал: идентификатор или число), например `:who = человек;`.
- **Семантика**: при вычислении узла сначала выполняется блок `{ }`: каждая переменная вычисляется (если значение — ветка, из неё выбирается один случайный лист). Затем полученные значения **подставляются** в блок выше там, где используются соответствующие параметры. Результат узла — «блок выше» с подставленными значениями (например, одна строка вида `привет мир` или структура для дальнейшего выбора).

Пример:

```text
[ привет; пока; 123; ]
```

Возможные результаты: `привет`, `пока` или `123`.

С вложенностью:

```text
[ [ a; b ]; [ c ]; 42; ]
```

Возможные результаты: `a`, `b`, `c` или `42` (равновероятный выбор среди листьев дерева).

Пример с переменными:

```text
[
  привет :who {
    :who = [
      мир;
      человек;
      робот;
    ]
  };
]
```

- В блоке выше используется `:who`; в блоке `{ }` переменная `:who` определена как ветка из трёх вариантов.
- Выполнение: из `:who` выбирается один случайный лист (мир / человек / робот), подставляется в «блок выше». Результат программы — один из: `привет мир`, `привет человек`, `привет робот`. Переменных в блоке может быть любое количество; все они вычисляются и подставляются в заголовок вызова.

Значение переменной может быть не только массивом, но и одной строкой (литералом):

```text
привет :who {
   :who = человек;
}
```

Тогда `:who` всегда подставляется как «человек» (без случайного выбора). То же для чисел: `:x = 42;`.

### Функции

- **Определение**: `!имя(:param1, :param2, ...) = значение` — имя с `!`, список параметров в скобках, тело — ветка (или узел). Определения располагаются на верхнем уровне программы, до основной ветки.
- **Вызов**: как и обычный вызов — `имя :p1 :p2 ... { :p1 = ...; :p2 = ... }`. Если `имя` — функция, блок задаёт значения параметров; тело функции вычисляется в этой среде (подстановка `:param` из блока), затем из результата (ветки) выбирается один случайный элемент.
- **В теле функции** параметры используются без блока: `привет :a` — значение `:a` берётся из среды вызова. То есть вызов с блоком даёт среду; вызов без блока (только `имя :a`) берёт параметры из текущей среды (контекст функции).

Пример:

```text
!func(:a) = [
  привет :a;
  пока :a;
]

[
  func :a { :a = [ мир; человек; робот; ] };
]
```

- Определена функция `func` с параметром `:a`; тело — ветка из двух элементов «привет :a» и «пока :a».
- В программе вызов `func :a { :a = [ мир; человек; робот; ] }`: из `:a` выбирается один вариант (мир/человек/робот), подставляется в тело; из ветки `[ привет :a; пока :a; ]` выбирается один элемент. Итог: один из «привет мир», «привет человек», «привет робот», «пока мир», «пока человек», «пока робот».

### Встроенные функции (Rust)

- **Обязательно** в языке есть **встроенные функции** — базовые операции над строками, реализованные **на Rust** в том же проекте (не на самом Branchy).
- **Вызов**: тот же синтаксис, что и у пользовательских функций (например `!upper(аргумент)` или как будет зафиксировано для FuncCall в плане вызова). Имя встроенной не пересекается с пользовательским определением (при совпадении имени можно приоритировать встроенную или запрещать переопределение).
- **Базовый набор для строк** (минимум): приведение к верхнему/нижнему регистру (`upper`, `lower`), обрезка пробелов с краёв (`trim`), конкатенация двух строк (`concat` или `join`), возможно длина (`len`), замена подстроки (`replace`), разбиение по разделителю (`split`) — точный список зафиксировать в модуле builtins. Аргументы и результат — строки; при необходимости несколько аргументов (например `concat(s1, s2)`, `replace(s, from, to)`).
- **Реализация**: отдельный модуль `src/builtins.rs` (или `src/builtin/` с несколькими файлами). Каждая функция — Rust-функция вида `fn(args: &[String]) -> Result<String, BuiltinError>`. Реестр встроенных (имя → функция) передаётся в интерпретатор; при разрешении вызова сначала проверяется реестр встроенных, затем пользовательские определения.
- **Тесты**: для каждой встроенной функции — юнит-тесты в Rust (вызов реализации с заданными аргументами, проверка результата) и интеграционные тесты (скрипт Branchy с вызовом встроенной, проверка вывода).

### Inline-block

- **Синтаксис**: `имя < вариант1 | вариант2 | ... >` — один идентификатор и в угловых скобках список вариантов через `|`.
- **Семантика**: то же, что один параметр с веткой из этих вариантов — при вычислении выбирается один случайный вариант, подставляется в заголовок. Удобный сокращённый вариант без имени параметра и без блока `{ }`.

Пример:

```text
[
  привет <мир|человек|робот>
]
```

Возможные результаты: `привет мир`, `привет человек`, `привет робот`. Внутри `< ... >` допустимы идентификаторы и числа (литералы); при необходимости можно разрешить и вложенные конструкции — для простоты достаточно только литералов.

---

## Бинарный формат

- **Назначение**: сохранять «скомпилированную» программу (AST) в файл и загружать без повторного парсинга. Интерпретатор принимает уже готовый `Program` — неважно, получен он парсером из текста или десериализацией из бинарника.
- **Содержимое**: сериализованный `Program` (functions + main). Все типы AST (`Program`, `FunctionDef`, `Node`, `Literal`) должны поддерживать сериализацию (см. ниже).
- **Стек**: `serde` + `bincode` (или `postcard` — компактно, no_alloc при желании). В начале файла — **магические байты** (например `b"BRCH"`) и **версия формата** (u8 или u16), чтобы при смене схемы можно было отклонять старые файлы или мигрировать.
- **Команды**:
  - Запуск по исходнику: `branchy run script.branchy` — парсинг → `Program` → интерпретатор.
  - Запуск по бинарнику: `branchy run script.branchyc` (или по расширению/флагу) — чтение байтов → десериализация → `Program` → интерпретатор.
  - Компиляция: `branchy compile script.branchy -o script.branchyc` — парсинг → сериализация в файл.
- **Зависимости**: добавить в `Cargo.toml`: `serde`, `serde_bytes` при необходимости, `bincode` (или `postcard`). Для AST и связанных структур — `#[derive(Serialize, Deserialize)]`.

---

## Структура проекта (Rust)

- **Cargo-проект**: `e:\.dev\.vibecoding\branchy` с `Cargo.toml` и `src/main.rs`.
- Зависимости: `rand`, `serde`, `bincode` (или `postcard`). Стандартная библиотека для остального.

### Разработка: Docker Compose и тесты

- **Запуск парсера/компилятора при разработке** — через **docker-compose**: образ с Rust-тулчейном (например `rust:latest` или `rust:bookworm`), монтирование кода в контейнер; команды `cargo build`, `cargo run`, `cargo test` выполняются внутри контейнера.
- **Обязательные тесты**: при любом запуске сборки/парсера/компилятора через docker-compose **сначала выполняются тесты** (`cargo test`). Если тесты не прошли — сборка/запуск не выполняются (или отдельный сервис/команда `test` в docker-compose, а `run`/`compile` зависят от него). Так обеспечивается, что изменения не ломают уже покрытые тестами виды выражений.
- **Варианты организации**:
  - Сервис `app`: `docker-compose run app cargo test && cargo run -- ...` — тесты, затем запуск.
  - Отдельный сервис `test`: `docker-compose run test` только запускает `cargo test`; в CI или перед ручным запуском вызывать сначала `docker-compose run test`, затем `docker-compose run app cargo run -- ...`.
  - Один сервис с entrypoint/script: при `docker-compose run branchy run script.branchy` скрипт сначала вызывает `cargo test`, при успехе — `cargo run -- run script.branchy`.
- В плане зафиксировать: в репозитории есть `docker-compose.yml`; команды разработки идут через docker-compose; тесты обязательны перед запуском парсера/компилятора.

---

## Модули и этапы

### 1. AST (древовидная структура)

- **Корень программы**: `Program { functions: Vec<FunctionDef>, main: Node }` — список функций и основная ветка.
- **FunctionDef** — `{ name: String, params: Vec<String>, body: Node }` (тело — обычно ветка).
- **Узел** — enum: `Branch(Vec<Node>)`, `Leaf(Literal)`, `Call { name, params, block: Option<Block> }` (блок опционален: при вызове без `{ }` параметры берутся из среды, см. функции), `InlineCall { name, options }`.
- **Literal** — enum: `Ident(String)` и `Num(...)` (на этапе парсинга; при интерпретации всё приводится к строке).
- Все типы AST должны реализовать `Serialize` и `Deserialize` (serde) для бинарного формата.
- При желании заложить расширение: тип результата вычисления/значения в среде — `String` сейчас; позже можно заменить на `enum Value { ... }`.

Файл: `src/ast.rs`.

### 2. Лексер (токены)

- Токены: `[`, `]`, `;`, `{`, `}`, `=`, `(`, `)`, `,`, `<`, `>`, `|`, `!`, идентификатор, **параметр** `:ident` (`Param(String)`), число.
- Пробелы и переносы строк между токенами игнорировать.

Файл: `src/lexer.rs`.

### 3. Парсер

- Рекурсивный спуск:
  - программа = (function_definition)* ветка;
  - function_definition = `!` ident `(` (Param (`,` Param)*)? `)` `=` значение (значение = ветка или узел);
  - ветка = `[` список_элементов `]`;
  - список_элементов = элемент (`;` элемент)* `;`?;
  - элемент = вызов | inline_call | ветка | идентификатор | число;
  - вызов = идентификатор (Param)* (`{` блок_определений `}`)? — без блока это вызов «из контекста» (параметры из среды, типично в теле функции);
  - inline_call = идентификатор `<` (элемент `|`)* элемент `>`;
  - блок_определений = (Param `=` значение `;`)* (значение = ветка или литерал).
- После идентификатора: если `(` — начало определения функции (уже разобрано как `!` ident); если `Param` и потом `{` — вызов с блоком; если только `Param`(s) без `{` — вызов без блока (params из env); если `<` — inline_call; иначе — литерал.
- Результат: `Program { functions, main }`.

Файл: `src/parser.rs`.

### 4. Интерпретатор (random pick + переменные + функции)

- Вход: `Program { functions, main }`. Контекст: таблица пользовательских функций по имени, **реестр встроенных функций** (имя → Rust-реализация), среда `env`.
- Для `Branch(children)` — выбрать один случайный дочерний узел, рекурсивно вычислить (с той же env).
- Для `Leaf(literal)` — вернуть этот литерал.
- Для вызова функции (FuncCall или Call с именем функции): **сначала** проверить, есть ли имя во **встроенных** (реестр из `builtins.rs`). Если да — вычислить аргументы до строк, вызвать Rust-функцию встроенной, вернуть результат как строку. Если нет — искать в пользовательских функциях и выполнять тело в среде (как сейчас).
- Для `Call { name, params, block }` (шаблон, не функция): вычислить блок → подстановка в заголовок. Для вызова без блока — параметры из env.
- Для `InlineCall { name, options }`: выбор одного варианта, подстановка в заголовок.
- RNG: крейт `rand`.

Файл: `src/interpreter.rs`.

### 4.1 Встроенные функции (модуль Rust)

- Модуль `**src/builtins.rs`**: реестр имён встроенных функций и их реализаций. Каждая реализация — функция Rust `fn(&[String]) -> Result<String, ...>`; при вызове интерпретатор передаёт аргументы (уже вычисленные в строки) и подставляет результат в выражение.
- **Базовые строковые функции** (примеры): `upper(s)`, `lower(s)`, `trim(s)`, `concat(s1, s2)` или `join(sep, s1, s2, ...)`, при желании `len(s)`, `replace(s, from, to)`, `split(s, sep)` (возврат — один выбранный элемент или строка; если возвращается несколько, формат согласовать с семантикой «одна строка»). Список зафиксировать в коде и в тестах.
- Реестр передаётся в интерпретатор при создании (или интерпретатор при инициализации подключает `builtins::default_registry()`).

Файл: `src/builtins.rs`.

### 5. Точка входа и бинарный формат

- **Запуск**: `branchy run <файл>` — по расширению или содержимому (магические байты) определить: если бинарник (например `.branchyc` или начало `BRCH`) — десериализовать в `Program`; иначе — парсинг текста → `Program`. Затем интерпретатор → вывод одного элемента.
- **Компиляция**: `branchy compile <вход.branchy> -o <выход.branchyc>` — парсинг → сериализация (магия + версия + bincode) в файл.
- Модуль сериализации: `src/binformat.rs` или в `src/lib.rs` — функции `serialize_program(Program) -> Vec<u8>`, `deserialize_program(bytes) -> Result<Program>` с проверкой магии и версии.
- Обработка ошибок: понятные сообщения при синтаксических ошибках и при несовместимом/битом бинарнике.

---

## Порядок реализации

1. Создать проект, добавить в `Cargo.toml`: `rand`, `serde`, `bincode` (или `postcard`).
2. Ввести типы AST с `#[derive(Serialize, Deserialize)]`: `Program`, `FunctionDef`, узлы, Literal.
3. Реализовать лексер и парсер (как выше).
4. Реализовать интерпретатор (вход — `Program`).
5. Реализовать **встроенные функции**: модуль `src/builtins.rs` с базовыми строковыми операциями (upper, lower, trim, concat/join, при необходимости len, replace, split); реестр имён и Rust-реализаций; интерпретатор при вызове по имени сначала проверяет встроенные, затем пользовательские функции. Тесты на каждую встроенную (юнит + вызов из Branchy-скрипта).
6. Реализовать бинарный формат: магия + версия + сериализация `Program`; модуль `serialize_program` / `deserialize_program` с проверкой магии и версии.
7. CLI: подкоманды или флаги — `run <файл>`, `compile <вход> -o <выход>`.
8. **Docker Compose**: добавить `docker-compose.yml` (образ Rust, монтирование проекта); команды разработки — через `docker-compose run ...`. При запуске парсера/компилятора **обязательно** сначала запускать тесты (`cargo test`); при падении тестов сборку/run не выполнять.

Семантика выбора: равновероятный выбор одного дочернего в каждой ветке; для переменных — один случайный лист при вычислении блока.

---

## Итог

Консольная утилита: вход — исходный файл (.branchy) или бинарник (.branchyc). Режим `run` — загрузка программы и вывод одного случайного элемента. Режим `compile` — сохранение AST в бинарном формате. Обязательны встроенные функции (базовые для строк), реализованные на Rust в том же проекте (`src/builtins.rs`), с тестами. Интерпретатор при вызове по имени сначала проверяет встроенные, затем пользовательские функции.